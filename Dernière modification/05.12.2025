# -*- coding: utf-8 -*-
# Cette ligne indique que le fichier utilise l'encodage UTF-8 pour g√©rer les caract√®res sp√©ciaux (accents, symboles, etc.)

# Importation des biblioth√®ques n√©cessaires
import webbrowser  # Permet d'ouvrir automatiquement un fichier HTML dans le navigateur par d√©faut
import os  # Permet d'interagir avec le syst√®me d'exploitation (fichiers, dossiers, chemins, etc.)
import html  # Permet d'√©chapper les caract√®res sp√©ciaux pour qu'ils s'affichent correctement en HTML
import platform  # Permet de d√©tecter le syst√®me d'exploitation (Windows, Linux, macOS) et d'autres informations syst√®me
import subprocess  # Permet d'ex√©cuter des commandes syst√®me (comme PowerShell, lsusb, etc.)
import re  # Permet d'utiliser les expressions r√©guli√®res pour analyser du texte
import sys  # Permet d'interagir avec l'interpr√©teur Python (par exemple, pour g√©rer la sortie standard)
import io  # Permet de g√©rer les flux d'entr√©e/sortie (par exemple, pour corriger l'encodage sous Windows)
from datetime import datetime  # Permet d'obtenir la date et l'heure actuelles
  
# Correction de l'encodage sous Windows
# Sous Windows, la sortie standard peut avoir des probl√®mes d'encodage.
# Cette ligne force l'encodage UTF-8 pour √©viter les erreurs d'affichage des caract√®res sp√©ciaux.
if platform.system() == "Windows":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')

# Fonction : D√©tecter les ports USB
def detecter_ports_usb():
    """
    Cette fonction d√©tecte tous les ports USB connect√©s √† l'ordinateur.
    Elle utilise des commandes diff√©rentes selon le syst√®me d'exploitation (Windows, Linux, macOS).
    Elle retourne une liste de dictionnaires, o√π chaque dictionnaire contient les informations d'un port USB.
    """
    systeme = platform.system()  # D√©tecte le syst√®me d'exploitation (Windows, Linux, Darwin pour macOS)
    ports_usb = []  # Liste vide pour stocker les informations des ports USB

    try:
        # D√©tection des ports USB sous Windows
        if systeme == "Windows":
            # Commande PowerShell pour lister les p√©riph√©riques USB
            cmd = ['powershell', '-Command', 'Get-PnpDevice -Class USB | Select-Object Status, FriendlyName, InstanceId']
            # Ex√©cution de la commande et r√©cup√©ration de la sortie
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            # Si la commande s'est ex√©cut√©e sans erreur
            if result.returncode == 0:
                # On analyse chaque ligne de la sortie (en ignorant les 3 premi√®res lignes qui sont des en-t√™tes)
                for ligne in result.stdout.strip().split('\n')[3:]:
                    if ligne.strip():  # Si la ligne n'est pas vide
                        parts = ligne.split(maxsplit=2)  # On divise la ligne en 3 parties maximum
                        if len(parts) >= 3:  # Si on a bien 3 parties (Statut, Nom, InstanceId)
                            ports_usb.append({
                                "nom": parts[1].strip(),  # Nom du p√©riph√©rique USB
                                "status": parts[0].strip(),  # Statut du p√©riph√©rique (OK, Erreur, etc.)
                                "instance_id": parts[2].strip(),  # Identifiant unique du p√©riph√©rique
                                "type": "USB"  # Type de p√©riph√©rique
                            })

        # D√©tection des ports USB sous Linux
    
        elif systeme == "Linux":
            # Commande lsusb pour lister les p√©riph√©riques USB
            result = subprocess.run(['lsusb'], capture_output=True, text=True, timeout=10)

            # Si la commande s'est ex√©cut√©e sans erreur
            if result.returncode == 0:
                # On analyse chaque ligne de la sortie
                for ligne in result.stdout.strip().split('\n'):
                    if ligne.strip():  # Si la ligne n'est pas vide
                        # On utilise une expression r√©guli√®re pour extraire le nom du p√©riph√©rique
                        match = re.search(r'Bus\s+\d+\s+Device\s+\d+:\s+ID\s+[\w:]+\s+(.+)', ligne)
                        if match:  # Si on a trouv√© une correspondance
                            ports_usb.append({
                                "nom": match.group(1).strip(),  # Nom du p√©riph√©rique USB
                                "status": "OK",  # Statut par d√©faut
                                "instance_id": ligne.split(':')[0].strip(),  # Identifiant du bus USB
                                "type": "USB"  # Type de p√©riph√©rique
                            })

        # D√©tection des ports USB sous macOS
        
        elif systeme == "Darwin":  # "Darwin" est le nom du noyau de macOS
            # Commande system_profiler pour lister les p√©riph√©riques USB
            result = subprocess.run(['system_profiler', 'SPUSBDataType'], capture_output=True, text=True, timeout=10)

            # Si la commande s'est ex√©cut√©e sans erreur
            if result.returncode == 0:
                lignes = result.stdout.split('\n')  # On divise la sortie en lignes
                current_device = {}  # Dictionnaire temporaire pour stocker les informations d'un p√©riph√©rique

                # On analyse chaque ligne de la sortie
                for ligne in lignes:
                    if 'Product ID:' in ligne:  # Si la ligne contient "Product ID:"
                        if current_device:  # Si on a d√©j√† un p√©riph√©rique en cours, on l'ajoute √† la liste
                            ports_usb.append(current_device)
                        # On initialise un nouveau dictionnaire pour le p√©riph√©rique actuel
                        current_device = {
                            "nom": ligne.split(':')[1].strip(),  # Nom du p√©riph√©rique
                            "status": "OK",  # Statut par d√©faut
                            "instance_id": "",  # Identifiant du p√©riph√©rique (vide pour l'instant)
                            "type": "USB"  # Type de p√©riph√©rique
                        }
                    elif 'Vendor ID:' in ligne:  # Si la ligne contient "Vendor ID:"
                        current_device["instance_id"] = ligne.split(':')[1].strip()  # On ajoute l'identifiant du vendeur

                # On ajoute le dernier p√©riph√©rique s'il existe
                if current_device:
                    ports_usb.append(current_device)

    # Si une erreur survient pendant la d√©tection des ports USB
    except Exception as e:
        print(f"‚ö† Erreur lors de la d√©tection USB : {str(e)}")

    return ports_usb  # Retourne la liste des ports USB d√©tect√©s

# Fonction : Analyser le syst√®me
def analyser_systeme():
    """
    Cette fonction analyse le syst√®me et les ports USB.
    Elle retourne un dictionnaire avec les informations syst√®me et les d√©tails des ports USB.
    """
    try:
        # V√©rifie si l'utilisateur est administrateur
        # Sous Windows, on utilise ctypes.windll.shell32.IsUserAnAdmin()
        # Sous Linux/macOS, on v√©rifie si l'UID est 0 (root)
        est_admin = (ctypes.windll.shell32.IsUserAnAdmin() != 0) if platform.system() == "Windows" else (os.geteuid() == 0)
    except:
        est_admin = False  # Par d√©faut, on consid√®re que l'utilisateur n'est pas administrateur

    print("üîç Analyse des ports USB en cours...")

    # Retourne un dictionnaire avec les informations syst√®me et les ports USB
    return {
        "systeme": platform.system(),  # Syst√®me d'exploitation (Windows, Linux, Darwin)
        "version": platform.version(),  # Version du syst√®me
        "processeur": platform.processor(),  # Type de processeur
        "ports_usb_details": detecter_ports_usb(),  # D√©tails des ports USB
        "nb_usb": len(detecter_ports_usb()),  # Nombre de ports USB d√©tect√©s
        "est_admin": est_admin  # True si l'utilisateur est administrateur, False sinon
    }

# Fonction : Afficher les informations syst√®me
def afficher_infos_systeme(infos):
    """
    Cette fonction affiche les informations syst√®me dans la console.
    """
    print("\nAnalyse du syst√®me en cours...\n")
    print(f"Syst√®me d√©tect√© : {infos['systeme']}")  # Affiche le syst√®me d'exploitation
    print(f"Version : {infos['version']}")  # Affiche la version du syst√®me
    print(f"Processeur : {infos['processeur']}")  # Affiche le type de processeur
    print(f"Nombre de ports USB d√©tect√©s : {infos['nb_usb']}")  # Affiche le nombre de ports USB
    # Affiche le type de compte (administrateur ou utilisateur standard)
    print(f"Type de compte : {'üëë Administrateur' if infos['est_admin'] else 'üë§ Utilisateur standard'}")

# Fonction : G√©n√©rer le contenu HTML du rapport
def generer_html(reponses):
    """
    Cette fonction g√©n√®re le contenu HTML du rapport d'analyse.
    Elle prend en entr√©e une liste de r√©ponses (analyses) et retourne une cha√Æne de caract√®res contenant le HTML.
    """
    # D√©but du contenu HTML avec le style CSS int√©gr√©
    contenu = f"""
    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Rapport d'analyse syst√®me</title>
        <style>
            /* Styles CSS pour rendre le rapport joli et lisible */
            body {{
                font-family: Arial, sans-serif;
                margin: 20px;
                background-color: #f5f5f5;
            }}
            .container {{
                max-width: 1400px;
                margin: 0 auto;
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }}
            h1, h2 {{
                color: #333;
                border-bottom: 2px solid #4CAF50;
                padding-bottom: 10px;
            }}
            table {{
                border-collapse: collapse;
                width: 100%;
                margin-top: 20px;
                font-size: 0.9em;
            }}
            th, td {{
                border: 1px solid #ddd;
                padding: 10px;
                text-align: left;
            }}
            th {{
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
            }}
            tr:nth-child(even) {{
                background-color: #f9f9f9;
            }}
            tr:hover {{
                background-color: #f1f1f1;
            }}
            .badge {{
                display: inline-block;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.85em;
                font-weight: bold;
            }}
            .badge-admin {{
                background-color: #ff9800;
                color: white;
            }}
            .badge-user {{
                background-color: #2196F3;
                color: white;
            }}
            .footer {{
                margin-top: 20px;
                text-align: center;
                color: #666;
                font-size: 0.9em;
            }}
            .usb-details {{
                margin-top: 20px;
                background-color: #f9f9f9;
                padding: 15px;
                border-radius: 5px;
            }}
            .usb-details h3 {{
                margin-top: 0;
                color: #4CAF50;
            }}
            .usb-table {{
                margin-top: 10px;
            }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üìä Historique des analyses USB</h1>
            <p><strong>Nombre total d'analyses :</strong> {len(reponses)}</p>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Nom d'utilisateur</th>
                        <th>Pr√©nom d'utilisateur</th>
                        <th>Num√©ro de Poste</th>
                        <th>Type de compte</th>
                        <th>Syst√®me</th>
                        <th>Processeur</th>
                        <th>Nombre de ports USB</th>
                        <th>Date et Heure</th>
                    </tr>
                </thead>
                <tbody>
    """

    # Pour chaque analyse dans la liste des r√©ponses
    for idx, rtest in enumerate(reponses, 1):
        # D√©termine la classe CSS pour le badge (administrateur ou utilisateur)
        badge_class = "badge-admin" if rtest['est_admin'] else "badge-user"
        badge_text = "Administrateur" if rtest['est_admin'] else "Utilisateur"

        # Ajoute une ligne au tableau pour cette analyse
        contenu += f"""
                    <tr>
                        <td>{idx}</td>
                        <td>{html.escape(rtest['nom_utilisateur'])}</td>
                        <td>{html.escape(rtest['prenom_utilisateur'])}</td>
                        <td>{html.escape(rtest['poste'])}</td>
                        <td><span class="badge {badge_class}">{badge_text}</span></td>
                        <td>{html.escape(rtest['systeme'])}</td>
                        <td>{html.escape(rtest['processeur'])}</td>
                        <td>{html.escape(str(rtest['nb_usb']))}</td>
                        <td>{html.escape(rtest['date_heure'])}</td>
                    </tr>
                    <tr>
                        <td colspan="9" class="usb-details">
                            <h3>üîå D√©tails des ports USB</h3>
                            <table class="usb-table">
                                <thead>
                                    <tr>
                                        <th>Nom</th>
                                        <th>Statut</th>
                                        <th>ID</th>
                                    </tr>
                                </thead>
                                <tbody>
        """

        # Pour chaque port USB de cette analyse
        for usb in rtest['ports_usb_details']:
            # Ajoute une ligne pour ce port USB
            contenu += f"""
                                    <tr>
                                        <td>{html.escape(usb['nom'])}</td>
                                        <td>{html.escape(usb['status'])}</td>
                                        <td>{html.escape(usb.get('instance_id', 'N/A'))}</td>
                                    </tr>
            """

        # Fermeture des balises pour cette analyse
        contenu += """
                                </tbody>
                            </table>
                        </td>
                    </tr>
        """

    # Fermeture des balises HTML
    contenu += """
                </tbody>
            </table>
            <div class="footer">
                <p>Rapport g√©n√©r√© automatiquement le """ + datetime.now().strftime("%d/%m/%Y √† %H:%M:%S") + """</p>
            </div>
        </div>
    </body>
    </html>
    """
    return contenu  # Retourne le contenu HTML g√©n√©r√©

# Fonction : Sauvegarder et ouvrir le rapport

def sauvegarder_et_ouvrir_rapport(reponses):
    """
    Cette fonction sauvegarde le rapport HTML dans un fichier et l'ouvre dans le navigateur par d√©faut.
    """
    fichier_html = "rapport_usb.html"  # Nom du fichier HTML
    # √âcrit le contenu HTML dans le fichier
    with open(fichier_html, "w", encoding="utf-8") as f:
        f.write(generer_html(reponses))

    chemin_absolu = os.path.abspath(fichier_html)  # R√©cup√®re le chemin absolu du fichier
    print(f"\n‚úì Rapport g√©n√©r√© : {chemin_absolu}")  # Affiche le chemin du rapport
    webbrowser.open("file://" + chemin_absolu)  # Ouvre le rapport dans le navigateur par d√©faut


# Fonction principale : main()

def main():
    """
    Fonction principale du programme.
    Elle g√®re l'interaction avec l'utilisateur et ex√©cute les analyses.
    """
    reponses_utilisateur = []  # Liste pour stocker les analyses effectu√©es

    # Affiche un en-t√™te pour le programme
    print("=" * 50 + "\n   ANALYSEUR DE SYST√àME USB\n" + "=" * 50)

    # Boucle principale pour permettre plusieurs analyses
    while True:
        print("\n" + "-" * 50)
        # Demande les informations de l'utilisateur
        nom_utilisateur = input("Nom d'utilisateur : ").strip()
        prenom_utilisateur = input("Pr√©nom d'utilisateur : ").strip()
        poste = input("Nom du poste ou num√©ro de poste : ").strip()

        # Message de bienvenue personnalis√©
        print(f"\nüëã {'Te revoil√†' if nom_utilisateur.lower() == 'camara' and prenom_utilisateur.lower() == 'ali' else 'Bonjour'}, {prenom_utilisateur} {nom_utilisateur} !")

        # Analyse le syst√®me et les ports USB
        infos_systeme = analyser_systeme()
        afficher_infos_systeme(infos_systeme)

        # Ajoute les informations de cette analyse √† la liste
        reponses_utilisateur.append({
            "nom_utilisateur": nom_utilisateur,
            "prenom_utilisateur": prenom_utilisateur,
            "poste": poste,
            "systeme": infos_systeme["systeme"],
            "processeur": infos_systeme["processeur"],
            "ports_usb_details": infos_systeme["ports_usb_details"],
            "nb_usb": infos_systeme["nb_usb"],
            "est_admin": infos_systeme["est_admin"],
            "date_heure": datetime.now().strftime("%d/%m/%Y %H:%M:%S")  # Date et heure de l'analyse
        })

        # Demande √† l'utilisateur s'il veut refaire une analyse
        reponse = input("\nüîÑ Souhaitez-vous refaire une analyse ? (oui/non) : ").strip().lower()
        while reponse not in ["oui", "non"]:
            reponse = input("‚ùå R√©ponse invalide. R√©pondez par 'oui' ou 'non' : ").strip().lower()

        if reponse != "oui":
            break  # Sort de la boucle si la r√©ponse est "non"

    # Si au moins une analyse a √©t√© effectu√©e, on g√©n√®re le rapport
    if reponses_utilisateur:
        sauvegarder_et_ouvrir_rapport(reponses_utilisateur)
        print("\nüëã Au revoir !")
    else:
        print("\n‚ö† Aucune analyse effectu√©e.")

# Point d'entr√©e du programme
if __name__ == "__main__":
    import ctypes  # Importation n√©cessaire pour v√©rifier les droits administrateur sous Windows
    main()  # Appelle la fonction principale pour d√©marrer le programme
